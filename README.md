# **🎮 Raonzena ( 우리 모두 즐거운 화상 게임 )**

👇라온제나 소개 및 시연 영상👇

라온제나 시나리오는 👉여기👈에서 더 자세히 보실 수 있습니다.

<br>

# Ⅰ. 서비스 소개

# 1. 서비스 설명

## 개요

- 한줄 소개 : 무료한 일상에서 벗어나 즐거움을 느끼고 싶은 현대인을 위한 `웹 화상 게임` 서비스
- 서비스 명 : 라온제나(Raonzena)
  - 즐거운 우리, 기쁜 우리라는 뜻으로•기쁨을 나누고 또 얻어갈 수 있는 장소라는 의미

## 🎯 타겟

- 시간적 / 공간적 제약으로 인해 오프라인으로 지인들과 시간을 보낼 수 없는 사람들
- 처음 보는 사람들과 무엇을 해야 할 지 머리가 하얘지는 사람들
- 👉 오프라인으로 재미있게 소통하고 싶은 모든 사람들

<br>

# 2. 기획 배경

## 배경

# 여기 바꿔주세욥!!!!!

우리는 프로젝트나 단체 활동에서 모르는 사람들과 팀을 꾸려 일을 시작할 때 어색함을 느끼곤 합니다. 나랑은 이러한 어색함이 제대로 해소되지 않고, 프로젝트를 진행했을 때 생기는 문제에 집중했습니다.

이 어색함은 서로에게 실례가 될까봐 의견을 제시하지 못하거나, 원하지 않는 의견에 어쩔수 없게 동의하여 프로젝트의 진행 과정과 성과에 불이익을 초래합니다.

반면 적절한 아이스브레이킹으로 팀원들간에 친밀감이 있는 상태에서 프로젝트가 진행되면 *1)일의 성과가 더 높고, *2)의사결정에 긍정적인 결과가 있다고 합니다.\*

---

## 🥅 목적

무료함에 지친 사람들이 즐거움을 경험하게 하자

## 의의

- 비대면 상황에서 직접 만나지 않고도 즐길 수 있는 온라인 웹 화상 게임
- 간단한 게임으로 서로를 더 잘 알아가고, 아이스브레이킹의 효과

<br>

# 3. 서비스 화면
## 랜딩페이지
> 라이브 페이지로 이동할 수 있는 버튼 
> 서비스 소개, 이용 가이드, 게임 가이드를 확인 가능
## 로그인
> 별도 회원가입 없이 카카오 로그인으로 전환
> 이후 라이브 페이지로 이동
## 라이브페이지
> 현재 진행중인 게임 방 리스트 확인 가능
> 하단에는 팔로우한 유저들의 상태와 해당 유저들의 참가중인 방 리스트 확인 가능
## 프로필페이지
> 해당 유저의 정보와 레벨, 그리고 작성한 피드들을 확인 가능
> 유저들의 팔로잉/팔로워 리스트 확인 가능
> 돋보기 아이콘을 통해 친구코드를 기반으로 유저 검색 가능
>
> 작성한 피드는 모달창을 통해 확인 가능
## 방 생성 페이지
> 방 생성을 위해서 방 정보 입력이 필요
> 현재 내 마이크와 카메라 상태을 확인 가능
> 비밀번호의 경우, 필요에 따라 활성화 가능
## 방 입장 전 페이지
> 방 입장 전 현재 내 마이크와 카메라 상태를 확인 가능
> 방 생성 과정에서 비밀번호를 입력 시 해당 방에 입장하기 위해선 비밀번호 입력이 필수
> 방에 참가하고 있는 유저 숫자를 표시하여 초과된 유저들의 입장을 방지
## MainRoom
> 화상의 경우 참여한 사람의 숫자에 따라 사이즈가 변동 됨
> 하부 아이콘들을 통해 다양한 기능들을 확인 가능
> 채팅의 경우 오른쪽 구역에서 채팅들을 확인 및 전송 가능
> 잡담 주제 아이콘을 선택해서 게인별로 원하는 잡담 주제 랜덤으로 확인 가능
### 게임
#### 이미지게임
- 시작과 함께 유저들은 손을 화면에 인식 시키게 됩니다
- 순서대로 돌아가며 키워드를 제시하며 제시어에 해당하는 유저는 손가락을 하나씩 접게 됩니다
- 모든 손가락이 접히게 되면 주먹을 인식하여, 탈락자로 채점되게 됩니다
#### 캐치마인드
- 방장은 주어진 키워드를 설명할 수 있는 그림을 그리게 됩니다
- 1분간 그림을 그리게 되고, 나머진 사람들은 답을 맞추게 됩니다
- 총 5개의 문제를 진행하게 되고, 시간을 초과하면 다음 문제로 넘어가게 됩니다

#### 고요 속의 외침
- 방장은 주어진 키워드를 30초간 음소거 상태로 설명하게 됩니다
- 해당 키워드의 문자 갯수가 화상 좌측 하단에 주어지게 됩니다
- 나머지 사람들은 해당 키워드를 유추하여 맞추게 됩니다
- 총 5개의 문제를 진행하며, 시간 초과시 넘어가게 됩니다
#### 인물 퀴즈
- 5초간 인물의 사진이 주어지게 됩니다
- 모든 참가자는 이름을 정답란에 제출하게 됩니다
- 시간안에 맞춘 모든 사람들은 점수를 받게 됩니다

#### 역전의 한방
- 모든 참가자들은 8개의 카드를 받게 됩니다
- 한 사람은 하나의 카드만을 선택할 수 있습니다
- 해당 카드에 적힌 효과로 점수의 변동이 발생합니다
사진 

* 추가적 전달 사항
<br>
<br>












# Ⅱ. 기술스택

# 1. webRTC (OpenVidu)
저희는 webRTC 구현에 Openvidu을 활용하였습니다. 주로 Openvidu 기술들을 활용하였으며, 데이터 공유가 된다는 점을 활용하여 게임 내의 화상의 차이를 구현하였습니다. 방에 입장을 하게 되면 소켓 연결을 통해 해당 방의 유저들과 자동으로 연결이 되고, 화상 연결을 통해 방의 모든 인원들이 자신의 화상을 자동으로 공유할 수 있게 구현하였습니다. 추가적으로 게임 내에서 역할에 따라 위치가 변동될 수 있도록 방의 생성자에게는 호스트 역할을 부여하였습니다.
# 2. Web Socket
webRTC로는 부족한 부분은 바로 게임 진행입니다. 같은 화면을 공유하는 것이 아닌 각자의 다른 웹 환경에 있기 때문에 따라서 이 부분을 통일성있는 모습으로 전환시키기 위해서는 소켓 통신을 적극적으로 활용하였습니다. 해당 게임의 시작과 정보, 그리고 정답 처리와 관련하여 소켓 통신을 활용하여 동일한 세션의 유저들은 동일한 구조의 컴포넌트들을 볼 수 있게 하였습니다. 또한 게임의 전환에 있어서 동일한 컴포넌트가 마운트 될 수 있도록 하는 부분에 있어서도 소켓 통신을 활용하였습니다.
# 3. Teachable Machine
이미지 게임에서 한 손을 화면에 보여주고 있어야 한다는 점에서 착안하여 해당 게임을 원할하게 온라인에서 즐기기 위해서는 채점 부분에 있어서 자동화를 통한 부분을 구현하는 것이 더욱 편리한 유저 경험을 제공할 수 있다는 기획 하에 티처블 머신을 활용하여 손을 인식하도록 구현하였습니다. 주먹과 손이 펴져있음을 구분하는 모델을 학습시켜 주먹이 쥐어진 상태가 특정 시간 지속된다면 해당 유저가 탈락되는 것으로 처리되도록 구현하였습니다. 
# 4. Redis

# 5. S3

# Ⅲ. 개발 환경 🖥️

## 🖥 Backend

    IntelliJ
    spring boot 2.7.7
    spring-boot-jpa
    Spring Security
    Java 11
    AWS EC2
    mysql 8.0.31
    redis
    S3

## 🖥 Frontend

    Visual Studio Code
    React.js 18.2.0
    redux 4.2.1
    redux-persist: 6.0.0

## 🖱 Web RTC

    openvidu-browser: 2.25.0

## 🖱 ImageGame

    Teachable Machine 0.8.5

## 🖱 CI/CD

    aws ec2
    docker
    nginx
    jenkins

## 🎨 UI/UX
    Figma

## 👨‍👩‍👧협업 툴

    Git
    Jira
    Notion
    Mattermost
    Webex

# Ⅳ. 프로젝트 진행

프로젝트 기간 - 2023.01.02 ~ 2023.02.17

# 1. git

1. git 브랜치를 만들 때 요구사항 정해진 기능에 맞는 번호를 찾는다.

2. 브랜치를 만들 떄 feature/파트/기능번호/서비스 형태를 지킨다  
   ex) feture/fe/1/로그인

3. commit을 작성할 때 정해진 틀을 지킨다.  
   3.1) Feat: 새로운 기능 추가, Fix: 버그 수정 등  
   3.2) 제목과 본문은 빈 행으로 분리  
   3.3) 제목 첫 글자는 대문자, 끝에는 . 금지  
   3.4) 제목은 한국어 기준 50자 이내  
   3.5) 한 commit message에 한가지 문제만 입력  
   ex) git commit -m "Feat:로그인 기능 추가"  

4. PR 컨벤션 작성 시 틀에 맞게 작성한다
   ex)

   ```markdown
   #### PR 타입(하나 이상의 PR 타입을 선택해주세요)

   -[] 기능 추가
   -[] 기능 삭제
   -[] 버그 수정
   -[] 의존성, 환경 변수, 빌드 관련 코드 업데이트

   ### 반영 브랜치

   ex) feat/login -> dev

   ### 변경 사항

   ex) 로그인 시, 구글 소셜 로그인 기능을 추가했습니다.
   ```

위와 같은 정해진 기준에 맞게 git을 사용했습니다. 또한 develop에 머지를 할 경우 최신 버전을 pull을 받고 merge를 실행했으며, merge할 때 충돌을 방지하기 위해 다른 팀원들에게 merge중임을 알렸습니다.

# 2. Jira

매주 월요일 오전 회의에서 차주에 진행되어야 할 것들을 정리하고 백로그에 등록했습니다. 금주에 완료하지 못한 이슈나, 앞으로 진행할 이슈들을 추가했습니다.

에픽은 가장 큰 단위의 기획, 설계, Backend 개발, Frontedn 개발 등으로 구성하였습니다.

스토리는 어떤 작업을 할 것인지에 대해 작성했습니다. [인생역전] 인생역전, [인물퀴즈] 인물퀴즈와 같이 작성했습니다.

작업은 스토리를 완료하기 위한 작은 업무 단위로 작성했습니다. 예를 들어 스토리 [인생역전] 인생역전 같은 경우 카드 구현, 카드 클릭 시 앞뒷면 변경, 카드에 해당하는 점수 부여 등으로 작성했습니다.

마지막으로 담당자와 스토리 포인트 설정, 활성 스프린트에서 현재 업무의 진행에 따라 할 일, 진행중, 완료 실시간으로 반영하는 것을 가장 중요하게 생각했습니다.

![image](https://user-images.githubusercontent.com/109517772/219319761-ed2d67c5-9d61-4dd3-91a2-7d74985ee689.png)

# 3. Notion

팀원들이 모두 공유해야할 자료 및 링크를 노션에 정리했습니다. API 설계, ERD, 컨벤션와 같이 여러번 다시 봐야하고 중요한 정보들과 프론트 작업장, 백엔드 작업장을 만들어 각 파트별 공통적으로 사용해야할 npm과 자료 등을 공유했습니다.

회의록에 매일 오전 회의를 하면서 각자 어제까지 진행한 사항 공유, 오늘 해야할 작업, 주요 안건을 작성했습니다.

# V. 프로젝트 산출물

## 💫서비스 아키텍처

![서비스아키텍처](/uploads/8ea7320094f2d7ada1d612699a867a5f/서비스아키텍처.png)

## 💭요구사항 정의서

요구사항 정의서

## 🎨 화면 설계서

화면설계서1

화면설계서2

---

✨Jenkins를 이용한 CD 구축 및 SSL 인증서 적용
제가 담당하여 서비스 아키텍처와 같이, Jenkins의 pipeline을 이용하여 자동 배포를 구축하였습니다. Gitlab webhook을 설정하여 Jenkins에 빌드 트리거를 설정했고, 이에 따라 Gitlab에서 master 브랜치에 push하면 자동으로 배포될 수 있도록 구축하여 개발하는 과정에서 배포로 인한 시간 낭비를 줄였습니다. 또한 프론트엔드인 React.js는 Nginx와 함께 docker image로 빌드하여 배포하였고, 백엔드 및 redis, openvidu 또한 docker container로 배포하였습니다. 그리고 Nginx와 letsencrypt를 이용하여 ssl 인증서를 적용하였고, 프론트엔드는 443(https)로 프록시로 분기시켰고 백엔드는 /api 경로로 프록시를 걸어줬습니다.

프로그램 배포 방법은 여기에서 볼 수 있습니다. 해당 배포 방법은 CI/CD를 구축할 수 있는 내용은 아닙니다.(단순 배포 방법)
✨기술 특이점
Teachable Machine
자세를 학습시켜 pose detection을 통한 모션 인식으로 자세 인식을 통해 유저가 각 운동 종목을 잘 수행하는지 체크했고, 운동 개수를 카운팅할 수 있도록 하였습니다.

티처블머신

이런 식으로 Teachable Machine으로 학습을 시키면 자세별로 도출된 값을 이용할 수 있게 됩니다. 여기서 추출된 코드와 값으로 홈동 서비스에 맞게 가공하여 구현하였습니다.

WebRTC (Openvidu)
Openvidu로만 할 수 있는 기능 뿐만이 아니라 백엔드를 함께 이용한 개발로 여러 기능을 구현했습니다. 각 방마다 인원수가 6명까지만 들어갈 수 있게 구현하였고, 방장만 게임을 시작할 수 있기에 방을 만들거나 방에서 인원이 나가면 자동으로 다른 사람에게 방장 권한이 부여되게 하였습니다. 그리고 private 방을 만들 수 있게 하여 방 번호와 비밀번호를 아는 사용자 외에는 들어오지 못하게 구현하였고, 빠른 시작 기능을 구현하여 현재 존재하는 방에 빠르게 입장할 수 있게 하였고, 방이 없으면 자동으로 방 생성까지 할 수 있도록 구현하였습니다.

Redis
랭킹 기능에 들어가는 랭킹 정보는 자정마다 업데이트 되는 정보여서 단순한 구조의 정보이고, 반복적으로 동일하게 제공되고, 최신화가 실시간으로 필요하지 않은 정보였습니다. 이러한 데이터의 특성으로 캐싱을 적용하기에 적절하다고 생각을 했고, Redis에 랭킹 정보를 저장하여 DB를 거치지 않고 정보를 가져와 트래픽이 많아질 때 백엔드 부하를 줄이고, 정보 조회 속도를 높였습니다. 또한 저희는 Spring Scurity와 JWT를 이용하여 인증을 구현하였는데, Redis를 이용해 로그아웃시킨 토큰들을 만료처리하여 해당 토큰으로는 다시 인증할 수 없도록 구현하였습니다.

redux-toolkit
프론트엔드 구현시에는 React와 redux-toolkit을 이용하여 Ducks Pattern 기반 상태 관리를 하였습니다.

배포
도커, Nginx, Jenkins를 이용한 자동 무중단 배포를 구현하였습니다. 백엔드를 도커 컨테이너로 배포하였고, 프론트로 Nginx와 함께 도커 컨테이너로 배포하였습니다.
